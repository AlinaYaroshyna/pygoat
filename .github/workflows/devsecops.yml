name: DevSecOps Pipeline (PyGoat)

on: [push, workflow_dispatch]

jobs:
  # 1. SCA (Software Composition Analysis)
  sca:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Run pip-audit
      run: |
        pip install pip-audit
        pip-audit --format json --output pip-audit-results.json || echo "SCA scan completed with findings"
        
    - name: Parse and create SCA issues
      uses: actions/github-script@v6
      if: success() || failure()  # Run even if previous step failed
      with:
        script: |
          const fs = require('fs');
          const { data: existingIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'security,sca'
          });
          
          try {
            const report = JSON.parse(fs.readFileSync('pip-audit-results.json'));
            const vulns = report.vulnerabilities || [];
            
            for (const vuln of vulns.filter(v => ['HIGH', 'CRITICAL'].includes(v.severity?.toUpperCase()))) {
              const issueTitle = `[SCA] ${vuln.name}@${vuln.installed_version}: ${vuln.description?.split('\n')[0] || 'No description'}`;
              
              const exists = existingIssues.some(issue => issue.title.includes(vuln.name));
              if (!exists) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: `**Vulnerability Details:**\n\n` +
                        `- Package: ${vuln.name}\n` +
                        `- Installed Version: ${vuln.installed_version}\n` +
                        `- Fixed Version: ${vuln.fixed_versions?.join(', ') || 'None'}\n` +
                        `- Severity: ${vuln.severity}\n` +
                        `- CVE: ${vuln.id}\n\n` +
                        `**Scan Report:** [View Results](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                  labels: ['security', 'sca', 'bug']
                });
              }
            }
          } catch (error) {
            core.warning(`Failed to process SCA results: ${error}`);
          }

  # 2. SAST (Static Analysis)
  sast:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Run Semgrep (latest version)
      id: semgrep_scan
      continue-on-error: true  # Kontynuuj nawet jeśli znajdzie podatności
      uses: returntocorp/semgrep-action@v2  # Najnowsza wersja akcji
      with:
        config: p/python
        output: semgrep-results.json
        severity: ERROR,WARNING  # Filtruj tylko ważne wyniki
        no-git-ignore: true  # Skanuj wszystkie pliki, nie tylko śledzone przez git
        metrics: off  # Wyłącz wysyłanie metryk jeśli chcesz
  
    - name: Show Semgrep summary
      if: always()
      run: |
        echo "=== Semgrep Results Summary ==="
        echo "Total findings: $(jq '.results | length' semgrep-results.json)"
        echo "High severity: $(jq '.results[] | select(.extra.severity == "ERROR") | length' semgrep-results.json)"
        echo "Medium severity: $(jq '.results[] | select(.extra.severity == "WARNING") | length' semgrep-results.json)"
  
    - name: Parse and create SAST issues
      uses: actions/github-script@v6
      if: always() && steps.semgrep_scan.outcome == 'success'  # Uruchom nawet jeśli skan znalazł problemy
      with:
        script: |
          const fs = require('fs');
          const { data: existingIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'security,sast'
          });
          
          try {
            const report = JSON.parse(fs.readFileSync('semgrep-results.json'));
            const criticalFindings = report.results.filter(
              f => ['ERROR', 'WARNING'].includes(f.extra.severity)
            );
  
            // Grupuj wyniki według reguły aby uniknąć duplikatów
            const groupedFindings = {};
            criticalFindings.forEach(finding => {
              const ruleId = finding.check_id;
              if (!groupedFindings[ruleId]) {
                groupedFindings[ruleId] = {
                  ...finding,
                  locations: [],
                  count: 0
                };
              }
              groupedFindings[ruleId].locations.push({
                path: finding.path,
                line: finding.start.line
              });
              groupedFindings[ruleId].count++;
            });
  
            // Twórz issue dla każdej reguły
            for (const [ruleId, finding] of Object.entries(groupedFindings)) {
              const issueTitle = `[SAST] ${finding.extra.message.split('\n')[0].substring(0, 100)}`;
              
              const exists = existingIssues.some(issue => 
                issue.title.includes(ruleId) &&
                issue.body.includes(`Rule ID: ${ruleId}`)
              );
              
              if (!exists && finding.count > 0) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: `**Finding:** ${finding.extra.message}\n\n` +
                        `**Severity:** ${finding.extra.severity}\n` +
                        `**Rule ID:** ${ruleId}\n` +
                        `**Found in ${finding.count} locations:**\n` +
                        finding.locations.map(loc => 
                          `- ${loc.path}:${loc.line}`
                        ).join('\n') + '\n\n' +
                        `**Scan Report:** [View Results](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                  labels: [
                    'security',
                    'sast',
                    finding.extra.severity.toLowerCase()
                  ]
                });
              }
            }
          } catch (error) {
            core.warning(`Failed to process SAST results: ${error}`);
          }
  # 3. Secrets Scan
  secrets:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Run Gitleaks
      uses: zricethezav/gitleaks-action@v2
      with:
        config-path: .gitleaks.toml
        redact: true
        report-format: json
        report-path: gitleaks-report.json
        
    - name: Parse and create Secrets issues
      uses: actions/github-script@v6
      if: always()
      with:
        script: |
          const fs = require('fs');
          const { data: existingIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'security,secrets'
          });
          
          try {
            const report = JSON.parse(fs.readFileSync('gitleaks-report.json'));
            
            for (const finding of report) {
              if (['HIGH', 'CRITICAL'].includes(finding.Match.toLowerCase())) {
                const issueTitle = `[Secrets] Potential ${finding.RuleID} exposed in ${finding.File}`;
                
                const exists = existingIssues.some(issue => 
                  issue.title.includes(finding.RuleID) && 
                  issue.body.includes(`File: ${finding.File}`)
                );
                
                if (!exists) {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: issueTitle,
                    body: `**Secret Type:** ${finding.RuleID}\n\n` +
                          `**File:** ${finding.File}\n` +
                          `**Line:** ${finding.StartLine}\n` +
                          `**Match:** ${finding.Match.substring(0, 50)}... [REDACTED]\n\n` +
                          `**Commit:** ${finding.Commit}\n\n` +
                          `**Scan Report:** [View Results](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                    labels: ['security', 'secrets', 'critical']
                  });
                }
              }
            }
          } catch (error) {
            core.warning(`Failed to process Secrets results: ${error}`);
          }

  # 4. DAST (Dynamic Analysis) - Your existing ZAP scan
  dast:
    runs-on: ubuntu-latest
    needs: [sca, sast, secrets]  # Run after other scans
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Build PyGoat Docker image
      run: docker build -t pygoat:latest .

    - name: Run PyGoat container
      run: |
        docker run -d --name pygoat-app -p 3000:3000 pygoat:latest
        sleep 15
        
    - name: Check if PyGoat is reachable
      run: curl -I http://localhost:3000 || echo "PyGoat is not responding"

    - name: ZAP Scan using GitHub Action
      uses: zaproxy/action-baseline@v0.14.0
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        target: 'http://localhost:3000'
        docker_name: 'ghcr.io/zaproxy/zaproxy:stable'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a'
        report_format: 'json'
        report_file: 'zap-report.json'
        
    - name: Parse and create DAST issues
      uses: actions/github-script@v6
      if: always()
      with:
        script: |
          const fs = require('fs');
          const { data: existingIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'security,dast'
          });
          
          try {
            const report = JSON.parse(fs.readFileSync('zap-report.json'));
            const sites = report.site || [];
            
            for (const site of sites) {
              for (const alert of site.alerts.filter(a => ['High', 'Critical'].includes(a.riskdesc))) {
                const issueTitle = `[DAST] ${alert.name} (${alert.riskdesc})`;
                const uniqueId = `dast-${alert.pluginid}-${alert.cweid || '0'}`;
                
                const exists = existingIssues.some(issue => 
                  issue.title.includes(alert.name) && 
                  issue.body.includes(`Risk: ${alert.riskdesc}`)
                );
                
                if (!exists) {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: issueTitle,
                    body: `**Vulnerability:** ${alert.name}\n\n` +
                          `**Risk Level:** ${alert.riskdesc}\n` +
                          `**Description:** ${alert.desc}\n\n` +
                          `**Solution:** ${alert.solution}\n\n` +
                          `**URL:** ${alert.url}\n` +
                          `**Scan Report:** [View Results](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                    labels: ['security', 'dast', alert.riskdesc.toLowerCase()]
                  });
                }
              }
            }
          } catch (error) {
            core.warning(`Failed to process DAST results: ${error}`);
          }

    - name: Stop and remove PyGoat container
      run: docker rm -f pygoat-app || true
