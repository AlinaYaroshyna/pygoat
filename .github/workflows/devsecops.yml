name: DevSecOps Pipeline (PyGoat)

on: [push, workflow_dispatch]

jobs:
  # 1. SCA (Software Composition Analysis)
  sca:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
        
    - name: Run pip-audit
      run: |
        pip install pip-audit
        pip-audit --format json --output pip-audit-results.json || echo "SCA scan completed with findings"
        
    - name: Parse and create SCA issues
      uses: actions/github-script@v6
      if: success() || failure()  # Run even if previous step failed
      with:
        script: |
          const fs = require('fs');
          const { data: existingIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'security,sca'
          });
          
          try {
            const report = JSON.parse(fs.readFileSync('pip-audit-results.json'));
            const vulns = report.vulnerabilities || [];
            
            for (const vuln of vulns.filter(v => ['HIGH', 'CRITICAL'].includes(v.severity?.toUpperCase()))) {
              const issueTitle = `[SCA] ${vuln.name}@${vuln.installed_version}: ${vuln.description?.split('\n')[0] || 'No description'}`;
              
              const exists = existingIssues.some(issue => issue.title.includes(vuln.name));
              if (!exists) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: `**Vulnerability Details:**\n\n` +
                        `- Package: ${vuln.name}\n` +
                        `- Installed Version: ${vuln.installed_version}\n` +
                        `- Fixed Version: ${vuln.fixed_versions?.join(', ') || 'None'}\n` +
                        `- Severity: ${vuln.severity}\n` +
                        `- CVE: ${vuln.id}\n\n` +
                        `**Scan Report:** [View Results](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                  labels: ['security', 'sca', 'bug']
                });
              }
            }
          } catch (error) {
            core.warning(`Failed to process SCA results: ${error}`);
          }

  # 2. SAST (Static Analysis)
  sast:
    runs-on: ubuntu-latest
    name: SAST Scan (Semgrep)
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Potrzebne do pełnego skanowania historii Git
  
      - name: Setup Semgrep
        id: semgrep
        uses: returntocorp/semgrep-action@v2
        continue-on-error: true  # Kontynuuj nawet jeśli znajdzie podatności
        with:
          config: "p/python"
          output: "semgrep-results.json"
          args: "--metrics=off --no-git-ignore"  # Dodatkowe argumenty CLI
  
      - name: Process findings
        if: always()  # Uruchom nawet jeśli poprzedni krok failuje
        run: |
          echo "=== Semgrep Results ==="
          if [ -f "semgrep-results.json" ]; then
            echo "Total findings: $(jq '.results | length' semgrep-results.json)"
            echo "High severity: $(jq '.results[] | select(.extra.severity == "ERROR") | length' semgrep-results.json || echo 0)"
            echo "Medium severity: $(jq '.results[] | select(.extra.severity == "WARNING") | length' semgrep-results.json || echo 0)"
          else
            echo "No results file found"
          fi
  
      - name: Upload results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: semgrep-results
          path: semgrep-results.json
  
      - name: Create GitHub Issues
        if: always() && github.event_name == 'push'  # Twórz issue tylko przy pushu
        uses: actions/github-script@v6
        env:
          SCAN_RESULTS: ${{ toJson(steps.semgrep.outputs) }}
        with:
          script: |
            try {
              const fs = require('fs');
              const { data: existingIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'security,sast'
              });
  
              if (fs.existsSync('semgrep-results.json')) {
                const report = JSON.parse(fs.readFileSync('semgrep-results.json', 'utf8'));
                const criticalFindings = report.results?.filter(f => 
                  ['ERROR', 'WARNING'].includes(f.extra?.severity)
                ) || [];
  
                // Grupowanie wyników
                const findingsMap = new Map();
                criticalFindings.forEach(finding => {
                  const key = finding.check_id;
                  if (!findingsMap.has(key)) {
                    findingsMap.set(key, {
                      ...finding,
                      locations: []
                    });
                  }
                  findingsMap.get(key).locations.push({
                    file: finding.path,
                    line: finding.start.line
                  });
                });
  
                // Tworzenie issue
                for (const [ruleId, finding] of findingsMap) {
                  const issueExists = existingIssues.some(
                    issue => issue.title.includes(ruleId) && issue.labels.some(l => l.name === 'sast')
                  );
  
                  if (!issueExists && finding.locations.length > 0) {
                    await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: `[SAST] ${finding.extra.message.substring(0, 100)}`,
                      body: `### ${finding.extra.severity} severity issue found\n\n` +
                            `**Rule:** ${finding.check_id}\n` +
                            `**Message:** ${finding.extra.message}\n\n` +
                            `**Found in ${finding.locations.length} locations:**\n` +
                            finding.locations.map(loc => `- \`${loc.file}:${loc.line}\``).join('\n') +
                            `\n\n**Scan details:** [View run](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                      labels: ['security', 'sast', finding.extra.severity.toLowerCase()]
                    });
                  }
                }
              }
            } catch (error) {
              core.warning(`SAST issue creation failed: ${error}`);
            }
  # 3. Secrets Scan
  secrets:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Run Gitleaks
      uses: zricethezav/gitleaks-action@v2
      with:
        config-path: .gitleaks.toml
        redact: true
        report-format: json
        report-path: gitleaks-report.json
        
    - name: Parse and create Secrets issues
      uses: actions/github-script@v6
      if: always()
      with:
        script: |
          const fs = require('fs');
          const { data: existingIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'security,secrets'
          });
          
          try {
            const report = JSON.parse(fs.readFileSync('gitleaks-report.json'));
            
            for (const finding of report) {
              if (['HIGH', 'CRITICAL'].includes(finding.Match.toLowerCase())) {
                const issueTitle = `[Secrets] Potential ${finding.RuleID} exposed in ${finding.File}`;
                
                const exists = existingIssues.some(issue => 
                  issue.title.includes(finding.RuleID) && 
                  issue.body.includes(`File: ${finding.File}`)
                );
                
                if (!exists) {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: issueTitle,
                    body: `**Secret Type:** ${finding.RuleID}\n\n` +
                          `**File:** ${finding.File}\n` +
                          `**Line:** ${finding.StartLine}\n` +
                          `**Match:** ${finding.Match.substring(0, 50)}... [REDACTED]\n\n` +
                          `**Commit:** ${finding.Commit}\n\n` +
                          `**Scan Report:** [View Results](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                    labels: ['security', 'secrets', 'critical']
                  });
                }
              }
            }
          } catch (error) {
            core.warning(`Failed to process Secrets results: ${error}`);
          }

  # 4. DAST (Dynamic Analysis) - Your existing ZAP scan
  dast:
    runs-on: ubuntu-latest
    needs: [sca, sast, secrets]  # Run after other scans
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Build PyGoat Docker image
      run: docker build -t pygoat:latest .

    - name: Run PyGoat container
      run: |
        docker run -d --name pygoat-app -p 3000:3000 pygoat:latest
        sleep 15
        
    - name: Check if PyGoat is reachable
      run: curl -I http://localhost:3000 || echo "PyGoat is not responding"

    - name: ZAP Scan using GitHub Action
      uses: zaproxy/action-baseline@v0.14.0
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        target: 'http://localhost:3000'
        docker_name: 'ghcr.io/zaproxy/zaproxy:stable'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a'
        report_format: 'json'
        report_file: 'zap-report.json'
        
    - name: Parse and create DAST issues
      uses: actions/github-script@v6
      if: always()
      with:
        script: |
          const fs = require('fs');
          const { data: existingIssues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'security,dast'
          });
          
          try {
            const report = JSON.parse(fs.readFileSync('zap-report.json'));
            const sites = report.site || [];
            
            for (const site of sites) {
              for (const alert of site.alerts.filter(a => ['High', 'Critical'].includes(a.riskdesc))) {
                const issueTitle = `[DAST] ${alert.name} (${alert.riskdesc})`;
                const uniqueId = `dast-${alert.pluginid}-${alert.cweid || '0'}`;
                
                const exists = existingIssues.some(issue => 
                  issue.title.includes(alert.name) && 
                  issue.body.includes(`Risk: ${alert.riskdesc}`)
                );
                
                if (!exists) {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: issueTitle,
                    body: `**Vulnerability:** ${alert.name}\n\n` +
                          `**Risk Level:** ${alert.riskdesc}\n` +
                          `**Description:** ${alert.desc}\n\n` +
                          `**Solution:** ${alert.solution}\n\n` +
                          `**URL:** ${alert.url}\n` +
                          `**Scan Report:** [View Results](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})`,
                    labels: ['security', 'dast', alert.riskdesc.toLowerCase()]
                  });
                }
              }
            }
          } catch (error) {
            core.warning(`Failed to process DAST results: ${error}`);
          }

    - name: Stop and remove PyGoat container
      run: docker rm -f pygoat-app || true
